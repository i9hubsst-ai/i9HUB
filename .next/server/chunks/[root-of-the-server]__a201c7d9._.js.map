{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\nimport { cookies } from 'next/headers'\n\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options)\n            )\n          } catch {\n            // Server Component context\n          }\n        },\n      },\n    }\n  )\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IAEjC,OAAO,IAAA,iMAAkB,sUAGvB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;gBAEjC,EAAE,OAAM;gBACN,2BAA2B;gBAC7B;YACF;QACF;IACF;AAEJ","debugId":null}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : ['error'],\n})\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY,CAAC;IAC/D,KAAK,uCAAyC;QAAC;QAAS;KAAO,GAAG;AACpE;AAEA,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/auth.ts"],"sourcesContent":["import { createClient } from '@/lib/supabase/server'\nimport { prisma } from '@/lib/prisma'\nimport { Role } from '@prisma/client'\n\nexport async function getCurrentUser() {\n  const supabase = await createClient()\n  const { data: { user }, error } = await supabase.auth.getUser()\n  \n  if (error || !user) {\n    return null\n  }\n  \n  return user\n}\n\nexport async function getUserMemberships(userId: string) {\n  return await prisma.membership.findMany({\n    where: {\n      userId,\n      status: 'ACTIVE'\n    },\n    include: {\n      company: true\n    },\n    orderBy: {\n      createdAt: 'desc'\n    }\n  })\n}\n\nexport async function isPlatformAdmin(userId: string): Promise<boolean> {\n  const admin = await prisma.platformAdmin.findUnique({\n    where: { userId }\n  })\n  return !!admin\n}\n\nexport async function getUserRole(userId: string, companyId: string): Promise<Role | null> {\n  const membership = await prisma.membership.findUnique({\n    where: {\n      userId_companyId: {\n        userId,\n        companyId\n      }\n    }\n  })\n  \n  return membership?.role ?? null\n}\n\nexport async function requireAuth() {\n  const user = await getCurrentUser()\n  if (!user) {\n    throw new Error('Unauthorized')\n  }\n  return user\n}\n\nexport async function requireRole(userId: string, companyId: string, allowedRoles: Role[]) {\n  const role = await getUserRole(userId, companyId)\n  const isAdmin = await isPlatformAdmin(userId)\n  \n  if (isAdmin) return true\n  \n  if (!role || !allowedRoles.includes(role)) {\n    throw new Error('Insufficient permissions')\n  }\n  \n  return true\n}\n\nexport async function getUserDisplayRole(userId: string): Promise<{ role: Role | 'PLATFORM_ADMIN', label: string }> {\n  // Check if user is Platform Admin first\n  const isAdmin = await isPlatformAdmin(userId)\n  \n  if (isAdmin) {\n    return {\n      role: 'PLATFORM_ADMIN',\n      label: 'Admin da Plataforma'\n    }\n  }\n  \n  // Get the user's primary membership (most recent active one)\n  const memberships = await getUserMemberships(userId)\n  \n  if (memberships.length === 0) {\n    return {\n      role: 'VIEWER',\n      label: 'Sem Acesso'\n    }\n  }\n  \n  // Use the first membership's role\n  const primaryRole = memberships[0].role\n  \n  const roleLabels: Record<Role, string> = {\n    PLATFORM_ADMIN: 'Admin da Plataforma',\n    COMPANY_ADMIN: 'Admin da Empresa',\n    ENGINEER: 'Engenheiro SST',\n    EMPLOYER: 'Empregador',\n    VIEWER: 'Visualizador'\n  }\n  \n  return {\n    role: primaryRole,\n    label: roleLabels[primaryRole]\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;;;AAGO,eAAe;IACpB,MAAM,WAAW,MAAM,IAAA,2IAAY;IACnC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAE7D,IAAI,SAAS,CAAC,MAAM;QAClB,OAAO;IACT;IAEA,OAAO;AACT;AAEO,eAAe,mBAAmB,MAAc;IACrD,OAAO,MAAM,yHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;QACtC,OAAO;YACL;YACA,QAAQ;QACV;QACA,SAAS;YACP,SAAS;QACX;QACA,SAAS;YACP,WAAW;QACb;IACF;AACF;AAEO,eAAe,gBAAgB,MAAc;IAClD,MAAM,QAAQ,MAAM,yHAAM,CAAC,aAAa,CAAC,UAAU,CAAC;QAClD,OAAO;YAAE;QAAO;IAClB;IACA,OAAO,CAAC,CAAC;AACX;AAEO,eAAe,YAAY,MAAc,EAAE,SAAiB;IACjE,MAAM,aAAa,MAAM,yHAAM,CAAC,UAAU,CAAC,UAAU,CAAC;QACpD,OAAO;YACL,kBAAkB;gBAChB;gBACA;YACF;QACF;IACF;IAEA,OAAO,YAAY,QAAQ;AAC7B;AAEO,eAAe;IACpB,MAAM,OAAO,MAAM;IACnB,IAAI,CAAC,MAAM;QACT,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEO,eAAe,YAAY,MAAc,EAAE,SAAiB,EAAE,YAAoB;IACvF,MAAM,OAAO,MAAM,YAAY,QAAQ;IACvC,MAAM,UAAU,MAAM,gBAAgB;IAEtC,IAAI,SAAS,OAAO;IAEpB,IAAI,CAAC,QAAQ,CAAC,aAAa,QAAQ,CAAC,OAAO;QACzC,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT;AAEO,eAAe,mBAAmB,MAAc;IACrD,wCAAwC;IACxC,MAAM,UAAU,MAAM,gBAAgB;IAEtC,IAAI,SAAS;QACX,OAAO;YACL,MAAM;YACN,OAAO;QACT;IACF;IAEA,6DAA6D;IAC7D,MAAM,cAAc,MAAM,mBAAmB;IAE7C,IAAI,YAAY,MAAM,KAAK,GAAG;QAC5B,OAAO;YACL,MAAM;YACN,OAAO;QACT;IACF;IAEA,kCAAkC;IAClC,MAAM,cAAc,WAAW,CAAC,EAAE,CAAC,IAAI;IAEvC,MAAM,aAAmC;QACvC,gBAAgB;QAChB,eAAe;QACf,UAAU;QACV,UAAU;QACV,QAAQ;IACV;IAEA,OAAO;QACL,MAAM;QACN,OAAO,UAAU,CAAC,YAAY;IAChC;AACF","debugId":null}},
    {"offset": {"line": 365, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/services/embedding-service.ts"],"sourcesContent":["/**\n * Serviço de Geração de Embeddings usando OpenAI\n * \n * Este serviço é responsável por:\n * 1. Gerar embeddings vetoriais de textos usando OpenAI API\n * 2. Armazenar embeddings no banco de dados\n * 3. Prover interface para busca vetorial\n */\n\nimport OpenAI from 'openai'\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY\n})\n\nexport interface EmbeddingInput {\n  text: string\n  sourceType: 'TEMPLATE' | 'ASSESSMENT' | 'ACTION_PLAN' | 'MTE_STANDARD' | 'ISO_STANDARD' | 'BEST_PRACTICE'\n  sourceId: string\n  metadata?: Record<string, any>\n}\n\nexport interface EmbeddingResult {\n  embedding: number[]\n  tokensUsed: number\n}\n\n/**\n * Gera embedding para um texto usando OpenAI text-embedding-3-small\n * Mais eficiente e barato que ada-002\n */\nexport async function generateEmbedding(text: string): Promise<EmbeddingResult> {\n  try {\n    const response = await openai.embeddings.create({\n      model: 'text-embedding-3-small',\n      input: text,\n      encoding_format: 'float'\n    })\n\n    return {\n      embedding: response.data[0].embedding,\n      tokensUsed: response.usage.total_tokens\n    }\n  } catch (error) {\n    console.error('Erro ao gerar embedding:', error)\n    throw new Error('Falha ao gerar embedding com OpenAI')\n  }\n}\n\n/**\n * Gera embeddings em lote (mais eficiente para múltiplos textos)\n */\nexport async function generateEmbeddingsBatch(texts: string[]): Promise<EmbeddingResult[]> {\n  if (texts.length === 0) {\n    return []\n  }\n\n  // OpenAI permite até 2048 inputs por request\n  const MAX_BATCH_SIZE = 100 // Sendo conservador\n  const results: EmbeddingResult[] = []\n\n  for (let i = 0; i < texts.length; i += MAX_BATCH_SIZE) {\n    const batch = texts.slice(i, i + MAX_BATCH_SIZE)\n    \n    try {\n      const response = await openai.embeddings.create({\n        model: 'text-embedding-3-small',\n        input: batch,\n        encoding_format: 'float'\n      })\n\n      const batchResults = response.data.map((item) => ({\n        embedding: item.embedding,\n        tokensUsed: response.usage.total_tokens / response.data.length // Aproximado\n      }))\n\n      results.push(...batchResults)\n    } catch (error) {\n      console.error(`Erro ao processar lote ${i / MAX_BATCH_SIZE + 1}:`, error)\n      throw error\n    }\n  }\n\n  return results\n}\n\n/**\n * Prepara texto para embedding (limpeza e truncamento)\n */\nexport function prepareTextForEmbedding(text: string, maxLength: number = 8000): string {\n  // Remove múltiplos espaços e quebras de linha\n  let cleaned = text\n    .replace(/\\s+/g, ' ')\n    .replace(/\\n+/g, '\\n')\n    .trim()\n\n  // Trunca se muito longo (OpenAI tem limite de ~8191 tokens)\n  if (cleaned.length > maxLength) {\n    cleaned = cleaned.substring(0, maxLength) + '...'\n  }\n\n  return cleaned\n}\n\n/**\n * Divide texto longo em chunks menores para embedding\n * Útil para normas muito longas\n */\nexport function chunkText(text: string, chunkSize: number = 2000, overlap: number = 200): string[] {\n  const chunks: string[] = []\n  let start = 0\n\n  while (start < text.length) {\n    const end = Math.min(start + chunkSize, text.length)\n    const chunk = text.substring(start, end)\n    chunks.push(chunk)\n    \n    // Overlap para manter contexto entre chunks\n    start = end - overlap\n    if (start >= text.length) break\n  }\n\n  return chunks\n}\n\n/**\n * Calcula similaridade de cosseno entre dois vetores\n */\nexport function cosineSimilarity(vecA: number[], vecB: number[]): number {\n  if (vecA.length !== vecB.length) {\n    throw new Error('Vetores devem ter o mesmo tamanho')\n  }\n\n  let dotProduct = 0\n  let normA = 0\n  let normB = 0\n\n  for (let i = 0; i < vecA.length; i++) {\n    dotProduct += vecA[i] * vecB[i]\n    normA += vecA[i] * vecA[i]\n    normB += vecB[i] * vecB[i]\n  }\n\n  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB))\n}\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;;;;;;;;;AAED;AAAA;;AAEA,MAAM,SAAS,IAAI,mLAAM,CAAC;IACxB,QAAQ,QAAQ,GAAG,CAAC,cAAc;AACpC;AAkBO,eAAe,kBAAkB,IAAY;IAClD,IAAI;QACF,MAAM,WAAW,MAAM,OAAO,UAAU,CAAC,MAAM,CAAC;YAC9C,OAAO;YACP,OAAO;YACP,iBAAiB;QACnB;QAEA,OAAO;YACL,WAAW,SAAS,IAAI,CAAC,EAAE,CAAC,SAAS;YACrC,YAAY,SAAS,KAAK,CAAC,YAAY;QACzC;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,MAAM,IAAI,MAAM;IAClB;AACF;AAKO,eAAe,wBAAwB,KAAe;IAC3D,IAAI,MAAM,MAAM,KAAK,GAAG;QACtB,OAAO,EAAE;IACX;IAEA,6CAA6C;IAC7C,MAAM,iBAAiB,IAAI,oBAAoB;;IAC/C,MAAM,UAA6B,EAAE;IAErC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,eAAgB;QACrD,MAAM,QAAQ,MAAM,KAAK,CAAC,GAAG,IAAI;QAEjC,IAAI;YACF,MAAM,WAAW,MAAM,OAAO,UAAU,CAAC,MAAM,CAAC;gBAC9C,OAAO;gBACP,OAAO;gBACP,iBAAiB;YACnB;YAEA,MAAM,eAAe,SAAS,IAAI,CAAC,GAAG,CAAC,CAAC,OAAS,CAAC;oBAChD,WAAW,KAAK,SAAS;oBACzB,YAAY,SAAS,KAAK,CAAC,YAAY,GAAG,SAAS,IAAI,CAAC,MAAM,CAAC,aAAa;gBAC9E,CAAC;YAED,QAAQ,IAAI,IAAI;QAClB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,uBAAuB,EAAE,IAAI,iBAAiB,EAAE,CAAC,CAAC,EAAE;YACnE,MAAM;QACR;IACF;IAEA,OAAO;AACT;AAKO,SAAS,wBAAwB,IAAY,EAAE,YAAoB,IAAI;IAC5E,8CAA8C;IAC9C,IAAI,UAAU,KACX,OAAO,CAAC,QAAQ,KAChB,OAAO,CAAC,QAAQ,MAChB,IAAI;IAEP,4DAA4D;IAC5D,IAAI,QAAQ,MAAM,GAAG,WAAW;QAC9B,UAAU,QAAQ,SAAS,CAAC,GAAG,aAAa;IAC9C;IAEA,OAAO;AACT;AAMO,SAAS,UAAU,IAAY,EAAE,YAAoB,IAAI,EAAE,UAAkB,GAAG;IACrF,MAAM,SAAmB,EAAE;IAC3B,IAAI,QAAQ;IAEZ,MAAO,QAAQ,KAAK,MAAM,CAAE;QAC1B,MAAM,MAAM,KAAK,GAAG,CAAC,QAAQ,WAAW,KAAK,MAAM;QACnD,MAAM,QAAQ,KAAK,SAAS,CAAC,OAAO;QACpC,OAAO,IAAI,CAAC;QAEZ,4CAA4C;QAC5C,QAAQ,MAAM;QACd,IAAI,SAAS,KAAK,MAAM,EAAE;IAC5B;IAEA,OAAO;AACT;AAKO,SAAS,iBAAiB,IAAc,EAAE,IAAc;IAC7D,IAAI,KAAK,MAAM,KAAK,KAAK,MAAM,EAAE;QAC/B,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,aAAa;IACjB,IAAI,QAAQ;IACZ,IAAI,QAAQ;IAEZ,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;QACpC,cAAc,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE;QAC/B,SAAS,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE;QAC1B,SAAS,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE;IAC5B;IAEA,OAAO,aAAa,CAAC,KAAK,IAAI,CAAC,SAAS,KAAK,IAAI,CAAC,MAAM;AAC1D","debugId":null}},
    {"offset": {"line": 474, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/services/rag-service.ts"],"sourcesContent":["/**\n * Serviço RAG (Retrieval-Augmented Generation)\n * \n * Fornece busca semântica sobre a base de conhecimento usando embeddings vetoriais\n */\n\nimport { prisma } from '@/lib/prisma'\nimport { generateEmbedding } from './embedding-service'\n\nexport interface RAGSearchResult {\n  id: string\n  content: string\n  sourceType: string\n  sourceId: string\n  metadata: any\n  similarity: number\n}\n\nexport interface RAGSearchOptions {\n  limit?: number\n  minSimilarity?: number\n  sourceTypes?: string[]\n  nrNumbers?: string[] // Filtrar por normas específicas\n}\n\n/**\n * Busca semântica na base de conhecimento\n */\nexport async function searchKnowledge(\n  query: string,\n  options: RAGSearchOptions = {}\n): Promise<RAGSearchResult[]> {\n  const {\n    limit = 5,\n    minSimilarity = 0.7,\n    sourceTypes,\n    nrNumbers\n  } = options\n\n  try {\n    // 1. Gerar embedding da query\n    const { embedding: queryEmbedding } = await generateEmbedding(query)\n    const embeddingVector = `[${queryEmbedding.join(',')}]`\n\n    // 2. Construir parâmetros e WHERE clause\n    // Importante: construir array de params ANTES de montar SQL para evitar problemas com índices\n    const params: any[] = [embeddingVector] // $1 sempre é o embedding\n    let whereClause = ''\n    \n    if (sourceTypes && sourceTypes.length > 0) {\n      params.push(sourceTypes)\n      whereClause += ` AND ke.\"sourceType\" = ANY($${params.length}::\"EmbeddingSourceType\"[])`\n    }\n\n    if (nrNumbers && nrNumbers.length > 0) {\n      params.push(nrNumbers)\n      whereClause += ` AND (ke.metadata->>'nrNumber') = ANY($${params.length}::text[])`\n    }\n\n    // Adicionar limit como último parâmetro\n    params.push(limit)\n    const limitParam = params.length\n\n    // 3. Busca vetorial usando pgvector\n    // Nota: pgvector usa operador <=> para distância de cosseno\n    const sql = `\n      SELECT \n        ke.id,\n        ke.content,\n        ke.\"sourceType\",\n        ke.\"sourceId\",\n        ke.metadata,\n        1 - (ke.embedding <=> $1::vector) as similarity\n      FROM knowledge_embeddings ke\n      WHERE 1=1 ${whereClause}\n      ORDER BY ke.embedding <=> $1::vector\n      LIMIT $${limitParam}\n    `\n\n    const results = await prisma.$queryRawUnsafe<any[]>(sql, ...params)\n\n    // 4. Filtrar por similaridade mínima\n    return results\n      .filter(r => r.similarity >= minSimilarity)\n      .map(r => ({\n        id: r.id,\n        content: r.content,\n        sourceType: r.sourceType,\n        sourceId: r.sourceId,\n        metadata: r.metadata,\n        similarity: Number(r.similarity)\n      }))\n\n  } catch (error) {\n    console.error('Erro na busca vetorial:', error)\n    throw new Error('Falha ao realizar busca semântica')\n  }\n}\n\n/**\n * Busca normas MTE relevantes para uma query\n */\nexport async function searchMteStandards(\n  query: string,\n  options: { limit?: number; nrNumbers?: string[] } = {}\n): Promise<RAGSearchResult[]> {\n  return searchKnowledge(query, {\n    ...options,\n    sourceTypes: ['MTE_STANDARD'],\n    minSimilarity: 0.75 // Threshold mais alto para normas\n  })\n}\n\n/**\n * Constrói contexto rico para a IA baseado em busca RAG\n */\nexport async function buildAIContext(\n  query: string,\n  options: {\n    includeStandards?: boolean\n    includeTemplates?: boolean\n    includeAssessments?: boolean\n    maxTokens?: number\n  } = {}\n): Promise<string> {\n  const {\n    includeStandards = true,\n    includeTemplates = true,\n    includeAssessments = false,\n    maxTokens = 4000\n  } = options\n\n  const sourceTypes: string[] = []\n  if (includeStandards) sourceTypes.push('MTE_STANDARD')\n  if (includeTemplates) sourceTypes.push('TEMPLATE')\n  if (includeAssessments) sourceTypes.push('ASSESSMENT')\n\n  // Buscar conhecimento relevante\n  const results = await searchKnowledge(query, {\n    limit: 10,\n    sourceTypes,\n    minSimilarity: 0.7\n  })\n\n  if (results.length === 0) {\n    return ''\n  }\n\n  // Construir contexto formatado\n  let context = '## Contexto Relevante da Base de Conhecimento:\\n\\n'\n  let currentTokens = 0\n\n  for (const result of results) {\n    const section = `### ${result.sourceType} (Similaridade: ${(result.similarity * 100).toFixed(1)}%)\\n`\n    const content = `${result.content}\\n\\n`\n    const metadata = result.metadata ? `*Metadados: ${JSON.stringify(result.metadata)}*\\n\\n` : ''\n    \n    const sectionText = section + content + metadata\n    const estimatedTokens = sectionText.length / 4 // Aproximação: 1 token ≈ 4 chars\n\n    if (currentTokens + estimatedTokens > maxTokens) {\n      break // Não exceder limite de tokens\n    }\n\n    context += sectionText\n    currentTokens += estimatedTokens\n  }\n\n  context += '---\\n\\n'\n  return context\n}\n\n/**\n * Encontra normas relacionadas a um tema específico\n */\nexport async function findRelatedStandards(\n  topic: string,\n  limit: number = 5\n): Promise<Array<{\n  nrNumber: string\n  title: string\n  relevantSections: string[]\n  similarity: number\n}>> {\n  const results = await searchMteStandards(topic, { limit: limit * 2 })\n\n  // Agrupar por NR\n  const byNr = new Map<string, RAGSearchResult[]>()\n  \n  for (const result of results) {\n    const nrNumber = result.metadata?.nrNumber || 'unknown'\n    if (!byNr.has(nrNumber)) {\n      byNr.set(nrNumber, [])\n    }\n    byNr.get(nrNumber)!.push(result)\n  }\n\n  // Consolidar resultados\n  const consolidated = Array.from(byNr.entries()).map(([nrNumber, chunks]) => {\n    const avgSimilarity = chunks.reduce((sum, c) => sum + c.similarity, 0) / chunks.length\n    const title = chunks[0]?.metadata?.title || nrNumber\n    const relevantSections = chunks\n      .map(c => c.content.substring(0, 200) + '...')\n      .slice(0, 3)\n\n    return {\n      nrNumber,\n      title,\n      relevantSections,\n      similarity: avgSimilarity\n    }\n  })\n\n  // Ordenar por similaridade e limitar\n  return consolidated\n    .sort((a, b) => b.similarity - a.similarity)\n    .slice(0, limit)\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 621, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/ai/template-builder/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { GoogleGenAI } from '@google/genai'\nimport { getCurrentUser, isPlatformAdmin } from '@/lib/auth'\nimport { buildAIContext } from '@/lib/services/rag-service'\n\nconst genai = new GoogleGenAI({\n  apiKey: process.env.GEMINI_API_KEY || '',\n})\n\ninterface TemplateBuilderRequest {\n  name: string\n  description: string\n  type: 'NR12' | 'NR35' | 'ISO45001' | 'ISO14001' | 'IMSST' | 'CUSTOM'\n  context?: string\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const user = await getCurrentUser()\n    if (!user) {\n      return NextResponse.json({ error: 'Não autorizado' }, { status: 401 })\n    }\n\n    const isAdmin = await isPlatformAdmin(user.id)\n    if (!isAdmin) {\n      return NextResponse.json(\n        { error: 'Apenas administradores podem gerar templates via IA' },\n        { status: 403 }\n      )\n    }\n\n    const body: TemplateBuilderRequest = await request.json()\n    const { name, description, type, context } = body\n\n    if (!name || !description || !type) {\n      return NextResponse.json(\n        { error: 'Nome, descrição e tipo são obrigatórios' },\n        { status: 400 }\n      )\n    }\n\n    // Buscar contexto normativo relevante via RAG\n    let ragContext = ''\n    let consultedStandards: string[] = []\n    \n    try {\n      // Construir query de busca baseada no tipo e descrição\n      const searchQuery = `${name} ${description} ${type}`\n      \n      // Buscar apenas normas MTE relevantes\n      ragContext = await buildAIContext(searchQuery, {\n        includeStandards: true,\n        includeTemplates: false,\n        includeAssessments: false,\n        maxTokens: 2000 // Limite para não sobrecarregar o prompt\n      })\n\n      // Extrair quais normas foram consultadas (para metadata)\n      const nrMatches = ragContext.match(/NR-\\d+/g)\n      if (nrMatches) {\n        consultedStandards = [...new Set(nrMatches)] // Remover duplicatas\n      }\n    } catch (error) {\n      console.log('Aviso: Não foi possível buscar contexto RAG:', error)\n      // Continuar sem contexto RAG se houver erro (graceful degradation)\n    }\n\n    const systemPrompt = `Você é um especialista em Segurança e Saúde no Trabalho (SST) no Brasil. Sua tarefa é gerar templates de diagnóstico detalhados e tecnicamente precisos para avaliações de SST.\n\n${ragContext ? `## CONTEXTO NORMATIVO RELEVANTE:\\n${ragContext}\\n\\nIMPORTANTE: Use as informações do contexto normativo acima para fundamentar suas perguntas e referências.\\n\\n` : ''}Um template consiste em:\n- **Seções**: Agrupamentos lógicos de perguntas (ex: \"Gestão de Riscos\", \"CIPA\")\n- **Perguntas**: Cada pergunta tem:\n  - text: Texto da pergunta claro e objetivo\n  - type: \"BOOLEAN\" (Sim/Não) ou \"SCORE\" (1-5)\n  - weight: Peso de 1-10 (importância da pergunta)\n  - reference: Referência normativa (ex: \"NR-12 item 12.3.1\")\n  - requiresJustification: true/false - se a pergunta exige que o usuário forneça uma justificativa textual para qualquer resposta\n  - requiresEvidence: true/false - se a pergunta exige que o usuário anexe evidências (fotos/documentos) para qualquer resposta\n\nIMPORTANTE:\n- Gere SEMPRE entre 20-30 perguntas no total, distribuídas entre 4-6 seções\n- Use pesos maiores (7-10) para itens críticos de segurança\n- Use pesos menores (3-5) para itens de documentação\n- Mix equilibrado de BOOLEAN e SCORE (cerca de 60% BOOLEAN, 40% SCORE)\n- Use requiresJustification=true em perguntas onde a explicação da resposta é importante (ex: não conformidades, itens críticos)\n- Use requiresEvidence=true em perguntas onde é necessário comprovar com documentos/fotos (ex: treinamentos, certificados, equipamentos)`\n\n    const userPrompt = `Gere um template de diagnóstico SST com as seguintes características:\n\n**Nome**: ${name}\n**Descrição**: ${description}\n**Tipo**: ${type}\n${context ? `**Contexto adicional**: ${context}` : ''}\n\nRetorne APENAS um JSON válido no seguinte formato (sem markdown, sem explicações):\n\n{\n  \"sections\": [\n    {\n      \"title\": \"Nome da Seção\",\n      \"description\": \"Descrição breve da seção\",\n      \"order\": 1,\n      \"questions\": [\n        {\n          \"text\": \"Texto da pergunta?\",\n          \"type\": \"BOOLEAN\",\n          \"weight\": 8,\n          \"reference\": \"NR-XX item X.X.X\",\n          \"requiresJustification\": true,\n          \"requiresEvidence\": false\n        }\n      ]\n    }\n  ]\n}`\n\n    const response = await genai.models.generateContent({\n      model: 'gemini-2.0-flash-exp',\n      config: {\n        systemInstruction: systemPrompt,\n        responseMimeType: 'application/json',\n      },\n      contents: userPrompt,\n    })\n\n    const content = response.text\n    if (!content) {\n      return NextResponse.json(\n        { error: 'IA não retornou conteúdo' },\n        { status: 500 }\n      )\n    }\n\n    const generatedTemplate = JSON.parse(content)\n\n    // Validar estrutura básica\n    if (!generatedTemplate.sections || !Array.isArray(generatedTemplate.sections)) {\n      return NextResponse.json(\n        { error: 'Template gerado tem formato inválido' },\n        { status: 500 }\n      )\n    }\n\n    return NextResponse.json({\n      success: true,\n      template: {\n        name,\n        description,\n        type,\n        sections: generatedTemplate.sections\n      },\n      metadata: {\n        ragEnabled: ragContext.length > 0,\n        consultedStandards: consultedStandards,\n        generatedAt: new Date().toISOString()\n      }\n    })\n\n  } catch (error) {\n    console.error('Erro ao gerar template via IA:', error)\n    return NextResponse.json(\n      { error: 'Erro ao gerar template via IA' },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}