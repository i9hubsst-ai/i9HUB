module.exports = [
"[project]/.next-internal/server/app/api/ai/template-builder/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/querystring [external] (querystring, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/node:events [external] (node:events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}),
"[externals]/node:process [external] (node:process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/fs/promises [external] (fs/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs/promises", () => require("fs/promises"));

module.exports = mod;
}),
"[project]/lib/supabase/server.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClient",
    ()=>createClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
async function createClient() {
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://zgnzobnearxgakhvxxyp.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpnbnpvYm5lYXJ4Z2FraHZ4eHlwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA5NzkzOTcsImV4cCI6MjA3NjU1NTM5N30.BWyq2vtOyX2syk8Zk_ynRpV10IqJ4_Xob0VZv_O5EDA"), {
        cookies: {
            getAll () {
                return cookieStore.getAll();
            },
            setAll (cookiesToSet) {
                try {
                    cookiesToSet.forEach(({ name, value, options })=>cookieStore.set(name, value, options));
                } catch  {
                // Server Component context
                }
            }
        }
    });
}
}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}),
"[project]/lib/prisma.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "prisma",
    ()=>prisma
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
;
const globalForPrisma = globalThis;
const prisma = globalForPrisma.prisma ?? new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]({
    log: ("TURBOPACK compile-time truthy", 1) ? [
        'error',
        'warn'
    ] : "TURBOPACK unreachable"
});
if ("TURBOPACK compile-time truthy", 1) globalForPrisma.prisma = prisma;
}),
"[project]/lib/auth.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getCurrentUser",
    ()=>getCurrentUser,
    "getUserDisplayRole",
    ()=>getUserDisplayRole,
    "getUserMemberships",
    ()=>getUserMemberships,
    "getUserRole",
    ()=>getUserRole,
    "isPlatformAdmin",
    ()=>isPlatformAdmin,
    "requireAuth",
    ()=>requireAuth,
    "requireRole",
    ()=>requireRole
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/supabase/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/prisma.ts [app-route] (ecmascript)");
;
;
async function getCurrentUser() {
    const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
    const { data: { user }, error } = await supabase.auth.getUser();
    if (error || !user) {
        return null;
    }
    return user;
}
async function getUserMemberships(userId) {
    return await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].membership.findMany({
        where: {
            userId,
            status: 'ACTIVE'
        },
        include: {
            company: true
        },
        orderBy: {
            createdAt: 'desc'
        }
    });
}
async function isPlatformAdmin(userId) {
    const admin = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].platformAdmin.findUnique({
        where: {
            userId
        }
    });
    return !!admin;
}
async function getUserRole(userId, companyId) {
    const membership = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].membership.findUnique({
        where: {
            userId_companyId: {
                userId,
                companyId
            }
        }
    });
    return membership?.role ?? null;
}
async function requireAuth() {
    const user = await getCurrentUser();
    if (!user) {
        throw new Error('Unauthorized');
    }
    return user;
}
async function requireRole(userId, companyId, allowedRoles) {
    const role = await getUserRole(userId, companyId);
    const isAdmin = await isPlatformAdmin(userId);
    if (isAdmin) return true;
    if (!role || !allowedRoles.includes(role)) {
        throw new Error('Insufficient permissions');
    }
    return true;
}
async function getUserDisplayRole(userId) {
    // Check if user is Platform Admin first
    const isAdmin = await isPlatformAdmin(userId);
    if (isAdmin) {
        return {
            role: 'PLATFORM_ADMIN',
            label: 'Admin da Plataforma'
        };
    }
    // Get the user's primary membership (most recent active one)
    const memberships = await getUserMemberships(userId);
    if (memberships.length === 0) {
        return {
            role: 'VIEWER',
            label: 'Sem Acesso'
        };
    }
    // Use the first membership's role
    const primaryRole = memberships[0].role;
    const roleLabels = {
        PLATFORM_ADMIN: 'Admin da Plataforma',
        COMPANY_ADMIN: 'Admin da Empresa',
        ENGINEER: 'Engenheiro SST',
        EMPLOYER: 'Empregador',
        VIEWER: 'Visualizador'
    };
    return {
        role: primaryRole,
        label: roleLabels[primaryRole]
    };
}
}),
"[project]/lib/services/embedding-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Serviço de Geração de Embeddings usando OpenAI
 * 
 * Este serviço é responsável por:
 * 1. Gerar embeddings vetoriais de textos usando OpenAI API
 * 2. Armazenar embeddings no banco de dados
 * 3. Prover interface para busca vetorial
 */ __turbopack_context__.s([
    "chunkText",
    ()=>chunkText,
    "cosineSimilarity",
    ()=>cosineSimilarity,
    "generateEmbedding",
    ()=>generateEmbedding,
    "generateEmbeddingsBatch",
    ()=>generateEmbeddingsBatch,
    "prepareTextForEmbedding",
    ()=>prepareTextForEmbedding
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/openai/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$client$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__OpenAI__as__default$3e$__ = __turbopack_context__.i("[project]/node_modules/openai/client.mjs [app-route] (ecmascript) <export OpenAI as default>");
;
const openai = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$client$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__OpenAI__as__default$3e$__["default"]({
    apiKey: process.env.OPENAI_API_KEY
});
async function generateEmbedding(text) {
    try {
        const response = await openai.embeddings.create({
            model: 'text-embedding-3-small',
            input: text,
            encoding_format: 'float'
        });
        return {
            embedding: response.data[0].embedding,
            tokensUsed: response.usage.total_tokens
        };
    } catch (error) {
        console.error('Erro ao gerar embedding:', error);
        throw new Error('Falha ao gerar embedding com OpenAI');
    }
}
async function generateEmbeddingsBatch(texts) {
    if (texts.length === 0) {
        return [];
    }
    // OpenAI permite até 2048 inputs por request
    const MAX_BATCH_SIZE = 100 // Sendo conservador
    ;
    const results = [];
    for(let i = 0; i < texts.length; i += MAX_BATCH_SIZE){
        const batch = texts.slice(i, i + MAX_BATCH_SIZE);
        try {
            const response = await openai.embeddings.create({
                model: 'text-embedding-3-small',
                input: batch,
                encoding_format: 'float'
            });
            const batchResults = response.data.map((item)=>({
                    embedding: item.embedding,
                    tokensUsed: response.usage.total_tokens / response.data.length // Aproximado
                }));
            results.push(...batchResults);
        } catch (error) {
            console.error(`Erro ao processar lote ${i / MAX_BATCH_SIZE + 1}:`, error);
            throw error;
        }
    }
    return results;
}
function prepareTextForEmbedding(text, maxLength = 8000) {
    // Remove múltiplos espaços e quebras de linha
    let cleaned = text.replace(/\s+/g, ' ').replace(/\n+/g, '\n').trim();
    // Trunca se muito longo (OpenAI tem limite de ~8191 tokens)
    if (cleaned.length > maxLength) {
        cleaned = cleaned.substring(0, maxLength) + '...';
    }
    return cleaned;
}
function chunkText(text, chunkSize = 2000, overlap = 200) {
    const chunks = [];
    let start = 0;
    while(start < text.length){
        const end = Math.min(start + chunkSize, text.length);
        const chunk = text.substring(start, end);
        chunks.push(chunk);
        // Overlap para manter contexto entre chunks
        start = end - overlap;
        if (start >= text.length) break;
    }
    return chunks;
}
function cosineSimilarity(vecA, vecB) {
    if (vecA.length !== vecB.length) {
        throw new Error('Vetores devem ter o mesmo tamanho');
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for(let i = 0; i < vecA.length; i++){
        dotProduct += vecA[i] * vecB[i];
        normA += vecA[i] * vecA[i];
        normB += vecB[i] * vecB[i];
    }
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}
}),
"[project]/lib/services/rag-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Serviço RAG (Retrieval-Augmented Generation)
 * 
 * Fornece busca semântica sobre a base de conhecimento usando embeddings vetoriais
 */ __turbopack_context__.s([
    "buildAIContext",
    ()=>buildAIContext,
    "findRelatedStandards",
    ()=>findRelatedStandards,
    "searchKnowledge",
    ()=>searchKnowledge,
    "searchMteStandards",
    ()=>searchMteStandards
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/prisma.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$services$2f$embedding$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/services/embedding-service.ts [app-route] (ecmascript)");
;
;
async function searchKnowledge(query, options = {}) {
    const { limit = 5, minSimilarity = 0.7, sourceTypes, nrNumbers } = options;
    try {
        // 1. Gerar embedding da query
        const { embedding: queryEmbedding } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$services$2f$embedding$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["generateEmbedding"])(query);
        const embeddingVector = `[${queryEmbedding.join(',')}]`;
        // 2. Construir parâmetros e WHERE clause
        // Importante: construir array de params ANTES de montar SQL para evitar problemas com índices
        const params = [
            embeddingVector
        ] // $1 sempre é o embedding
        ;
        let whereClause = '';
        if (sourceTypes && sourceTypes.length > 0) {
            params.push(sourceTypes);
            whereClause += ` AND ke."sourceType" = ANY($${params.length}::"EmbeddingSourceType"[])`;
        }
        if (nrNumbers && nrNumbers.length > 0) {
            params.push(nrNumbers);
            whereClause += ` AND (ke.metadata->>'nrNumber') = ANY($${params.length}::text[])`;
        }
        // Adicionar limit como último parâmetro
        params.push(limit);
        const limitParam = params.length;
        // 3. Busca vetorial usando pgvector
        // Nota: pgvector usa operador <=> para distância de cosseno
        const sql = `
      SELECT 
        ke.id,
        ke.content,
        ke."sourceType",
        ke."sourceId",
        ke.metadata,
        1 - (ke.embedding <=> $1::vector) as similarity
      FROM knowledge_embeddings ke
      WHERE 1=1 ${whereClause}
      ORDER BY ke.embedding <=> $1::vector
      LIMIT $${limitParam}
    `;
        const results = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].$queryRawUnsafe(sql, ...params);
        // 4. Filtrar por similaridade mínima
        return results.filter((r)=>r.similarity >= minSimilarity).map((r)=>({
                id: r.id,
                content: r.content,
                sourceType: r.sourceType,
                sourceId: r.sourceId,
                metadata: r.metadata,
                similarity: Number(r.similarity)
            }));
    } catch (error) {
        console.error('Erro na busca vetorial:', error);
        throw new Error('Falha ao realizar busca semântica');
    }
}
async function searchMteStandards(query, options = {}) {
    return searchKnowledge(query, {
        ...options,
        sourceTypes: [
            'MTE_STANDARD'
        ],
        minSimilarity: 0.75 // Threshold mais alto para normas
    });
}
async function buildAIContext(query, options = {}) {
    const { includeStandards = true, includeTemplates = true, includeAssessments = false, maxTokens = 4000 } = options;
    const sourceTypes = [];
    if (includeStandards) sourceTypes.push('MTE_STANDARD');
    if (includeTemplates) sourceTypes.push('TEMPLATE');
    if (includeAssessments) sourceTypes.push('ASSESSMENT');
    // Buscar conhecimento relevante
    const results = await searchKnowledge(query, {
        limit: 10,
        sourceTypes,
        minSimilarity: 0.7
    });
    if (results.length === 0) {
        return '';
    }
    // Construir contexto formatado
    let context = '## Contexto Relevante da Base de Conhecimento:\n\n';
    let currentTokens = 0;
    for (const result of results){
        const section = `### ${result.sourceType} (Similaridade: ${(result.similarity * 100).toFixed(1)}%)\n`;
        const content = `${result.content}\n\n`;
        const metadata = result.metadata ? `*Metadados: ${JSON.stringify(result.metadata)}*\n\n` : '';
        const sectionText = section + content + metadata;
        const estimatedTokens = sectionText.length / 4 // Aproximação: 1 token ≈ 4 chars
        ;
        if (currentTokens + estimatedTokens > maxTokens) {
            break; // Não exceder limite de tokens
        }
        context += sectionText;
        currentTokens += estimatedTokens;
    }
    context += '---\n\n';
    return context;
}
async function findRelatedStandards(topic, limit = 5) {
    const results = await searchMteStandards(topic, {
        limit: limit * 2
    });
    // Agrupar por NR
    const byNr = new Map();
    for (const result of results){
        const nrNumber = result.metadata?.nrNumber || 'unknown';
        if (!byNr.has(nrNumber)) {
            byNr.set(nrNumber, []);
        }
        byNr.get(nrNumber).push(result);
    }
    // Consolidar resultados
    const consolidated = Array.from(byNr.entries()).map(([nrNumber, chunks])=>{
        const avgSimilarity = chunks.reduce((sum, c)=>sum + c.similarity, 0) / chunks.length;
        const title = chunks[0]?.metadata?.title || nrNumber;
        const relevantSections = chunks.map((c)=>c.content.substring(0, 200) + '...').slice(0, 3);
        return {
            nrNumber,
            title,
            relevantSections,
            similarity: avgSimilarity
        };
    });
    // Ordenar por similaridade e limitar
    return consolidated.sort((a, b)=>b.similarity - a.similarity).slice(0, limit);
}
}),
"[project]/app/api/ai/template-builder/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/genai/dist/node/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/auth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$services$2f$rag$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/services/rag-service.ts [app-route] (ecmascript)");
;
;
;
;
const genai = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleGenAI"]({
    apiKey: process.env.GEMINI_API_KEY || ''
});
async function POST(request) {
    try {
        const user = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCurrentUser"])();
        if (!user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Não autorizado'
            }, {
                status: 401
            });
        }
        const isAdmin = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isPlatformAdmin"])(user.id);
        if (!isAdmin) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Apenas administradores podem gerar templates via IA'
            }, {
                status: 403
            });
        }
        const body = await request.json();
        const { name, description, type, context } = body;
        if (!name || !description || !type) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Nome, descrição e tipo são obrigatórios'
            }, {
                status: 400
            });
        }
        // Buscar contexto normativo relevante via RAG
        let ragContext = '';
        let consultedStandards = [];
        try {
            // Construir query de busca baseada no tipo e descrição
            const searchQuery = `${name} ${description} ${type}`;
            // Buscar apenas normas MTE relevantes
            ragContext = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$services$2f$rag$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["buildAIContext"])(searchQuery, {
                includeStandards: true,
                includeTemplates: false,
                includeAssessments: false,
                maxTokens: 2000 // Limite para não sobrecarregar o prompt
            });
            // Extrair quais normas foram consultadas (para metadata)
            const nrMatches = ragContext.match(/NR-\d+/g);
            if (nrMatches) {
                consultedStandards = [
                    ...new Set(nrMatches)
                ]; // Remover duplicatas
            }
        } catch (error) {
            console.log('Aviso: Não foi possível buscar contexto RAG:', error);
        // Continuar sem contexto RAG se houver erro (graceful degradation)
        }
        const systemPrompt = `Você é um especialista em Segurança e Saúde no Trabalho (SST) no Brasil. Sua tarefa é gerar templates de diagnóstico detalhados e tecnicamente precisos para avaliações de SST.

${ragContext ? `## CONTEXTO NORMATIVO RELEVANTE:\n${ragContext}\n\nIMPORTANTE: Use as informações do contexto normativo acima para fundamentar suas perguntas e referências.\n\n` : ''}Um template consiste em:
- **Seções**: Agrupamentos lógicos de perguntas (ex: "Gestão de Riscos", "CIPA")
- **Perguntas**: Cada pergunta tem:
  - text: Texto da pergunta claro e objetivo
  - type: "BOOLEAN" (Sim/Não) ou "SCORE" (1-5)
  - weight: Peso de 1-10 (importância da pergunta)
  - reference: Referência normativa (ex: "NR-12 item 12.3.1")
  - requiresJustification: true/false - se a pergunta exige que o usuário forneça uma justificativa textual para qualquer resposta
  - requiresEvidence: true/false - se a pergunta exige que o usuário anexe evidências (fotos/documentos) para qualquer resposta

IMPORTANTE:
- Gere SEMPRE entre 20-30 perguntas no total, distribuídas entre 4-6 seções
- Use pesos maiores (7-10) para itens críticos de segurança
- Use pesos menores (3-5) para itens de documentação
- Mix equilibrado de BOOLEAN e SCORE (cerca de 60% BOOLEAN, 40% SCORE)
- Use requiresJustification=true em perguntas onde a explicação da resposta é importante (ex: não conformidades, itens críticos)
- Use requiresEvidence=true em perguntas onde é necessário comprovar com documentos/fotos (ex: treinamentos, certificados, equipamentos)`;
        const userPrompt = `Gere um template de diagnóstico SST com as seguintes características:

**Nome**: ${name}
**Descrição**: ${description}
**Tipo**: ${type}
${context ? `**Contexto adicional**: ${context}` : ''}

Retorne APENAS um JSON válido no seguinte formato (sem markdown, sem explicações):

{
  "sections": [
    {
      "title": "Nome da Seção",
      "description": "Descrição breve da seção",
      "order": 1,
      "questions": [
        {
          "text": "Texto da pergunta?",
          "type": "BOOLEAN",
          "weight": 8,
          "reference": "NR-XX item X.X.X",
          "requiresJustification": true,
          "requiresEvidence": false
        }
      ]
    }
  ]
}`;
        const response = await genai.models.generateContent({
            model: 'gemini-2.0-flash-exp',
            config: {
                systemInstruction: systemPrompt,
                responseMimeType: 'application/json'
            },
            contents: userPrompt
        });
        const content = response.text;
        if (!content) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'IA não retornou conteúdo'
            }, {
                status: 500
            });
        }
        const generatedTemplate = JSON.parse(content);
        // Validar estrutura básica
        if (!generatedTemplate.sections || !Array.isArray(generatedTemplate.sections)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Template gerado tem formato inválido'
            }, {
                status: 500
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            template: {
                name,
                description,
                type,
                sections: generatedTemplate.sections
            },
            metadata: {
                ragEnabled: ragContext.length > 0,
                consultedStandards: consultedStandards,
                generatedAt: new Date().toISOString()
            }
        });
    } catch (error) {
        console.error('Erro ao gerar template via IA:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Erro ao gerar template via IA'
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__a201c7d9._.js.map